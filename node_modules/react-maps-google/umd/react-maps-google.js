/*! react-maps-google v0.4.11 | (c) 2021 Ryan Hefner | MIT License | https://github.com/ryanhefner/react-maps-google !*/
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['react-maps-google'] = {}, global.React, global.ReactDOM));
}(this, (function (exports, React, ReactDOM) { 'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
	var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
	var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
	var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
	var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

	var reactIs_production_min = {
		AsyncMode: AsyncMode,
		ConcurrentMode: ConcurrentMode,
		ContextConsumer: ContextConsumer,
		ContextProvider: ContextProvider,
		Element: Element,
		ForwardRef: ForwardRef,
		Fragment: Fragment,
		Lazy: Lazy,
		Memo: Memo,
		Portal: Portal,
		Profiler: Profiler,
		StrictMode: StrictMode,
		Suspense: Suspense,
		isAsyncMode: isAsyncMode,
		isConcurrentMode: isConcurrentMode,
		isContextConsumer: isContextConsumer,
		isContextProvider: isContextProvider,
		isElement: isElement,
		isForwardRef: isForwardRef,
		isFragment: isFragment,
		isLazy: isLazy,
		isMemo: isMemo,
		isPortal: isPortal,
		isProfiler: isProfiler,
		isStrictMode: isStrictMode,
		isSuspense: isSuspense,
		isValidElementType: isValidElementType,
		typeOf: typeOf
	};

	var reactIs_development = createCommonjsModule(function (module, exports) {



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	exports.AsyncMode = AsyncMode;
	exports.ConcurrentMode = ConcurrentMode;
	exports.ContextConsumer = ContextConsumer;
	exports.ContextProvider = ContextProvider;
	exports.Element = Element;
	exports.ForwardRef = ForwardRef;
	exports.Fragment = Fragment;
	exports.Lazy = Lazy;
	exports.Memo = Memo;
	exports.Portal = Portal;
	exports.Profiler = Profiler;
	exports.StrictMode = StrictMode;
	exports.Suspense = Suspense;
	exports.isAsyncMode = isAsyncMode;
	exports.isConcurrentMode = isConcurrentMode;
	exports.isContextConsumer = isContextConsumer;
	exports.isContextProvider = isContextProvider;
	exports.isElement = isElement;
	exports.isForwardRef = isForwardRef;
	exports.isFragment = isFragment;
	exports.isLazy = isLazy;
	exports.isMemo = isMemo;
	exports.isPortal = isPortal;
	exports.isProfiler = isProfiler;
	exports.isStrictMode = isStrictMode;
	exports.isSuspense = isSuspense;
	exports.isValidElementType = isValidElementType;
	exports.typeOf = typeOf;
	  })();
	}
	});
	reactIs_development.AsyncMode;
	reactIs_development.ConcurrentMode;
	reactIs_development.ContextConsumer;
	reactIs_development.ContextProvider;
	reactIs_development.Element;
	reactIs_development.ForwardRef;
	reactIs_development.Fragment;
	reactIs_development.Lazy;
	reactIs_development.Memo;
	reactIs_development.Portal;
	reactIs_development.Profiler;
	reactIs_development.StrictMode;
	reactIs_development.Suspense;
	reactIs_development.isAsyncMode;
	reactIs_development.isConcurrentMode;
	reactIs_development.isContextConsumer;
	reactIs_development.isContextProvider;
	reactIs_development.isElement;
	reactIs_development.isForwardRef;
	reactIs_development.isFragment;
	reactIs_development.isLazy;
	reactIs_development.isMemo;
	reactIs_development.isPortal;
	reactIs_development.isProfiler;
	reactIs_development.isStrictMode;
	reactIs_development.isSuspense;
	reactIs_development.isValidElementType;
	reactIs_development.typeOf;

	var reactIs = createCommonjsModule(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = reactIs_production_min;
	} else {
	  module.exports = reactIs_development;
	}
	});

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

	var printWarning$1 = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = ReactPropTypesSecret_1;
	  var loggedTypeFailures = {};
	  var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

	  printWarning$1 = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has$1(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning$1(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning$1(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};

	var checkPropTypes_1 = checkPropTypes;

	var has = Function.call.bind(Object.prototype.hasOwnProperty);
	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret_1) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!reactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = objectAssign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes_1;
	  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	var factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret_1) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	var propTypes = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	if (process.env.NODE_ENV !== 'production') {
	  var ReactIs = reactIs;

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = factoryWithThrowingShims();
	}
	});

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$3(subClass, superClass); }

	function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }
	var CALLBACK_MAP$2 = {
	  'center_changed': 'onCenterChanged',
	  'click': 'onClick',
	  'dblclick': 'onDoubleClick',
	  'drag': 'onDrag',
	  'dragend': 'onDragEnd',
	  'dragstart': 'onDragStart',
	  'mousedown': 'onMouseDown',
	  'mousemove': 'onMouseMove',
	  'mouseout': 'onMouseOut',
	  'mouseover': 'onMouseOver',
	  'mouseup': 'onMouseUp',
	  'radius_changed': 'onRadiusChanged',
	  'rightclick': 'onRightClick',
	  'visible_changed': 'onVisibleChanged',
	  'zindex_changed': 'onZIndexChanged'
	};
	var defaultOptions = {
	  fillColor: '#1774ff',
	  fillOpacity: 0.2,
	  strokeColor: '#1774ff',
	  strokeWeight: 2
	};

	var Circle = /*#__PURE__*/function (_Component) {
	  _inheritsLoose$3(Circle, _Component);

	  function Circle() {
	    return _Component.apply(this, arguments) || this;
	  }

	  var _proto = Circle.prototype;

	  _proto.componentDidMount = function componentDidMount() {
	    if (this.props.map) {
	      this.renderCircle(this.props);
	    }
	  };

	  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
	    var _this$props = this.props,
	        map = _this$props.map,
	        center = _this$props.center,
	        radius = _this$props.radius,
	        options = _this$props.options;
	    var renderCircle = false;

	    if (map !== prevProps.map) {
	      renderCircle = true;
	    }

	    if (!Object.is(center, prevProps.center)) {
	      renderCircle = true;
	    }

	    if (radius !== prevProps.radius) {
	      renderCircle = true;
	    }

	    if (!Object.is(options, prevProps.options)) {
	      renderCircle = true;
	    }

	    if (renderCircle) {
	      this.renderCircle(this.props);
	    }
	  };

	  _proto.componentWillUnmount = function componentWillUnmount() {
	    if (!this.circle) {
	      return;
	    }

	    google.maps.event.clearInstanceListeners(this.circle);
	    this.circle.setMap(null);
	  };

	  _proto.onCircleCallback = function onCircleCallback(callback, event) {
	    if (this.props[callback]) {
	      this.props[callback](this.circle, event);
	    }
	  };

	  _proto.renderCircle = function renderCircle(props) {
	    var _this = this;

	    var map = props.map,
	        options = props.options,
	        center = props.center,
	        radius = props.radius;

	    if (!map) {
	      return;
	    }

	    if (!this.circle) {
	      this.circle = new google.maps.Circle(_objectSpread$1(_objectSpread$1({}, Object.assign({}, defaultOptions, options)), {}, {
	        map: map,
	        center: center,
	        radius: radius
	      }));
	      Object.keys(CALLBACK_MAP$2).forEach(function (key) {
	        google.maps.event.addListener(_this.circle, key, _this.onCircleCallback.bind(_this, CALLBACK_MAP$2[key]));
	      });
	      return;
	    }

	    this.circle.setOptions(_objectSpread$1(_objectSpread$1({}, Object.assign({}, defaultOptions, options)), {}, {
	      map: map,
	      center: center,
	      radius: radius
	    }));
	  };

	  _proto.render = function render() {
	    return null;
	  };

	  return Circle;
	}(React.Component);

	Circle.propTypes = {
	  map: propTypes.object,
	  center: propTypes.object.isRequired,
	  radius: propTypes.number,
	  options: propTypes.object,
	  onCenterChanged: propTypes.func,
	  onClick: propTypes.func,
	  onDoubleClick: propTypes.func,
	  onDrag: propTypes.func,
	  onDragEnd: propTypes.func,
	  onDragStart: propTypes.func,
	  onMouseDown: propTypes.func,
	  onMouseMove: propTypes.func,
	  onMouseOut: propTypes.func,
	  onMouseOver: propTypes.func,
	  onMouseUp: propTypes.func,
	  onRadiusChanged: propTypes.func,
	  onRightClick: propTypes.func,
	  onVisibleChange: propTypes.func,
	  onZIndexChange: propTypes.func
	};
	Circle.defaultProps = {
	  options: defaultOptions,
	  radius: 1000,
	  onCenterChanged: function onCenterChanged(circle) {},
	  onClick: function onClick(circle) {},
	  onDoubleClick: function onDoubleClick(circle) {},
	  onDrag: function onDrag(circle) {},
	  onDragEnd: function onDragEnd(circle) {},
	  onDragStart: function onDragStart(circle) {},
	  onMouseDown: function onMouseDown(circle) {},
	  onMouseMove: function onMouseMove(circle) {},
	  onMouseOut: function onMouseOut(circle) {},
	  onMouseOver: function onMouseOver(circle) {},
	  onMouseUp: function onMouseUp(circle) {},
	  onRadiusChanged: function onRadiusChanged(circle) {},
	  onRightClick: function onRightClick(circle) {},
	  onVisibleChanged: function onVisibleChanged(circle) {},
	  onZIndexChanged: function onZIndexChanged(circle) {}
	};

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$2(subClass, superClass); }

	function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }
	var CALLBACK_MAP$1 = {
	  'animation_changed': 'onAnimationChange',
	  'click': 'onClick',
	  'clickable_changed': 'onClickableChange',
	  'cursor_changed': 'onCursorChange',
	  'dblclick': 'onDoubleClick',
	  'drag': 'onDrag',
	  'dragend': 'onDragEnd',
	  'draggable_changed': 'onDraggableChange',
	  'dragstart': 'onDragStart',
	  'flat_changed': 'onFlatChange',
	  'icon_changed': 'onIconChange',
	  'mousedown': 'onMouseDown',
	  'mouseout': 'onMouseOut',
	  'mouseover': 'onMouseOver',
	  'mouseup': 'onMouseUp',
	  'position_changed': 'onPositionChange',
	  'rightclick': 'onRightClick',
	  'shape_changed': 'onShapeChange',
	  'title_changed': 'onTitleChange',
	  'visible_changed': 'onVisibleChange',
	  'zindex_changed': 'onZIndexChange'
	};

	var Marker = /*#__PURE__*/function (_Component) {
	  _inheritsLoose$2(Marker, _Component);

	  function Marker() {
	    return _Component.apply(this, arguments) || this;
	  }

	  var _proto = Marker.prototype;

	  _proto.componentDidMount = function componentDidMount() {
	    if (this.props.map) {
	      this.renderMarker(this.props);
	    }
	  };

	  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
	    var _this$props = this.props,
	        map = _this$props.map,
	        position = _this$props.position,
	        options = _this$props.options;
	    var renderMarker = false;

	    if (map !== prevProps.map) {
	      renderMarker = true;
	    }

	    if (!Object.is(position, prevProps.position)) {
	      renderMarker = true;
	    }

	    if (!Object.is(options, prevProps.options)) {
	      renderMarker = true;
	    }

	    if (renderMarker) {
	      this.renderMarker(this.props);
	    }
	  };

	  _proto.componentWillUnmount = function componentWillUnmount() {
	    if (!this.marker) {
	      return;
	    }

	    google.maps.event.clearInstanceListeners(this.marker);
	    this.marker.setMap(null);
	  };

	  _proto.onMarkerCallback = function onMarkerCallback(callback, event) {
	    if (this.props[callback]) {
	      this.props[callback](this.marker, event);
	    }
	  };

	  _proto.renderMarker = function renderMarker(props) {
	    var _this = this;

	    var map = props.map,
	        options = props.options,
	        position = props.position;
	        props.width;
	        props.height;

	    if (!map) {
	      return;
	    }

	    if (!this.marker) {
	      this.marker = new google.maps.Marker(_objectSpread(_objectSpread({}, options), {}, {
	        map: map,
	        position: position
	      }));
	      Object.keys(CALLBACK_MAP$1).forEach(function (key) {
	        google.maps.event.addListener(_this.marker, key, _this.onMarkerCallback.bind(_this, CALLBACK_MAP$1[key]));
	      });
	      return;
	    }

	    this.marker.setOptions(_objectSpread(_objectSpread({}, options), {}, {
	      map: map,
	      position: position
	    }));
	  };

	  _proto.render = function render() {
	    return null;
	  };

	  return Marker;
	}(React.Component);

	Marker.propTypes = {
	  map: propTypes.object,
	  options: propTypes.object,
	  position: propTypes.object.isRequired,
	  onAnimationChange: propTypes.func,
	  onClick: propTypes.func,
	  onClickableChange: propTypes.func,
	  onCursorChange: propTypes.func,
	  onDoubleClick: propTypes.func,
	  onDrag: propTypes.func,
	  onDragEnd: propTypes.func,
	  onDraggableChange: propTypes.func,
	  onDragStart: propTypes.func,
	  onFlatChange: propTypes.func,
	  onIconChange: propTypes.func,
	  onMouseDown: propTypes.func,
	  onMouseOut: propTypes.func,
	  onMouseOver: propTypes.func,
	  onMouseUp: propTypes.func,
	  onPositionChange: propTypes.func,
	  onRightClick: propTypes.func,
	  onShapeChange: propTypes.func,
	  onTitleChange: propTypes.func,
	  onVisibleChange: propTypes.func,
	  onZIndexChange: propTypes.func
	};
	Marker.defaultProps = {
	  options: {},
	  onAnimationChange: function onAnimationChange(marker) {},
	  onClick: function onClick(marker, event) {},
	  onClickableChange: function onClickableChange(marker) {},
	  onCursorChange: function onCursorChange(marker) {},
	  onDoubleClick: function onDoubleClick(marker, event) {},
	  onDrag: function onDrag(marker, event) {},
	  onDragEnd: function onDragEnd(marker, event) {},
	  onDraggableChange: function onDraggableChange(marker) {},
	  onDragStart: function onDragStart(marker, event) {},
	  onFlatChange: function onFlatChange(marker) {},
	  onIconChange: function onIconChange(marker) {},
	  onMouseDown: function onMouseDown(marker, event) {},
	  onMouseOut: function onMouseOut(marker, event) {},
	  onMouseOver: function onMouseOver(marker, event) {},
	  onMouseUp: function onMouseUp(marker, event) {},
	  onPositionChange: function onPositionChange(marker) {},
	  onRightClick: function onRightClick(marker, event) {},
	  onShapeChange: function onShapeChange(marker) {},
	  onTitleChange: function onTitleChange(marker) {},
	  onVisibleChange: function onVisibleChange(marker) {},
	  onZIndexChange: function onZIndexChange(marker) {}
	};

	var lib = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



	var _react2 = _interopRequireDefault(React__default['default']);



	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Script = function (_React$Component) {
	  _inherits(Script, _React$Component);

	  // A dictionary mapping script URL to a boolean value indicating if the script
	  // has failed to load.


	  // A dictionary mapping script URLs to a dictionary mapping
	  // component key to component for all components that are waiting
	  // for the script to load.
	  function Script(props) {
	    _classCallCheck(this, Script);

	    var _this = _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).call(this, props));

	    _this.scriptLoaderId = 'id' + _this.constructor.idCount++; // eslint-disable-line space-unary-ops, no-plusplus
	    return _this;
	  }

	  // A counter used to generate a unique id for each component that uses
	  // ScriptLoaderMixin.


	  // A dictionary mapping script URL to a boolean value indicating if the script
	  // has already been loaded.


	  _createClass(Script, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          onError = _props.onError,
	          onLoad = _props.onLoad,
	          url = _props.url;


	      if (this.constructor.loadedScripts[url]) {
	        onLoad();
	        return;
	      }

	      if (this.constructor.erroredScripts[url]) {
	        onError();
	        return;
	      }

	      // If the script is loading, add the component to the script's observers
	      // and return. Otherwise, initialize the script's observers with the component
	      // and start loading the script.
	      if (this.constructor.scriptObservers[url]) {
	        this.constructor.scriptObservers[url][this.scriptLoaderId] = this.props;
	        return;
	      }

	      this.constructor.scriptObservers[url] = _defineProperty({}, this.scriptLoaderId, this.props);

	      this.createScript();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      var url = this.props.url;

	      var observers = this.constructor.scriptObservers[url];

	      // If the component is waiting for the script to load, remove the
	      // component from the script's observers before unmounting the component.
	      if (observers) {
	        delete observers[this.scriptLoaderId];
	      }
	    }
	  }, {
	    key: 'createScript',
	    value: function createScript() {
	      var _this2 = this;

	      var _props2 = this.props,
	          onCreate = _props2.onCreate,
	          url = _props2.url,
	          attributes = _props2.attributes;

	      var script = document.createElement('script');

	      onCreate();

	      // add 'data-' or non standard attributes to the script tag
	      if (attributes) {
	        Object.keys(attributes).forEach(function (prop) {
	          return script.setAttribute(prop, attributes[prop]);
	        });
	      }

	      script.src = url;

	      // default async to true if not set with custom attributes
	      if (!script.hasAttribute('async')) {
	        script.async = 1;
	      }

	      var callObserverFuncAndRemoveObserver = function callObserverFuncAndRemoveObserver(shouldRemoveObserver) {
	        var observers = _this2.constructor.scriptObservers[url];
	        Object.keys(observers).forEach(function (key) {
	          if (shouldRemoveObserver(observers[key])) {
	            delete _this2.constructor.scriptObservers[url][_this2.scriptLoaderId];
	          }
	        });
	      };
	      script.onload = function () {
	        _this2.constructor.loadedScripts[url] = true;
	        callObserverFuncAndRemoveObserver(function (observer) {
	          observer.onLoad();
	          return true;
	        });
	      };

	      script.onerror = function () {
	        _this2.constructor.erroredScripts[url] = true;
	        callObserverFuncAndRemoveObserver(function (observer) {
	          observer.onError();
	          return true;
	        });
	      };

	      document.body.appendChild(script);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return null;
	    }
	  }]);

	  return Script;
	}(_react2.default.Component);

	Script.propTypes = {
	  attributes: propTypes.PropTypes.object, // eslint-disable-line react/forbid-prop-types
	  onCreate: propTypes.PropTypes.func,
	  onError: propTypes.PropTypes.func.isRequired,
	  onLoad: propTypes.PropTypes.func.isRequired,
	  url: propTypes.PropTypes.string.isRequired
	};
	Script.defaultProps = {
	  attributes: {},
	  onCreate: function onCreate() {},
	  onError: function onError() {},
	  onLoad: function onLoad() {} };
	Script.scriptObservers = {};
	Script.loadedScripts = {};
	Script.erroredScripts = {};
	Script.idCount = 0;
	exports.default = Script;
	module.exports = exports['default'];
	});

	var Script = unwrapExports(lib);

	function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$1(subClass, superClass); }

	function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

	var MarkerClusterer = /*#__PURE__*/function (_Component) {
	  _inheritsLoose$1(MarkerClusterer, _Component);

	  function MarkerClusterer(props) {
	    var _this;

	    _this = _Component.call(this, props) || this;
	    _this.state = {
	      scriptLoaded: false
	    };
	    _this.onScriptLoad = _this.onScriptLoad.bind(_assertThisInitialized$1(_this));
	    return _this;
	  }

	  var _proto = MarkerClusterer.prototype;

	  _proto.componentDidUpdate = function componentDidUpdate() {
	    this.renderMarkerClusterer(this.props);
	  };

	  _proto.componentWillUnmount = function componentWillUnmount() {
	    if (!this.markerClusterer) {
	      return;
	    }

	    this.markerClusterer.clearMarkers();
	  };

	  _proto.onScriptLoad = function onScriptLoad() {
	    this.setState({
	      scriptLoaded: true
	    });
	    this.renderMarkerClusterer(this.props);
	  };

	  _proto.renderMarkerClusterer = function renderMarkerClusterer(props) {
	    var map = props.map,
	        markers = props.markers;

	    if (!map) {
	      return;
	    }

	    if (!this.markerClusterer) {
	      this.markerClusterer = new MarkerClusterer(map, markers);
	      return;
	    }
	    /**
	     * @todo Review props and apply updates to this.markerClusterer. - Ryan
	     */

	  };

	  _proto.render = function render() {
	    return /*#__PURE__*/React__default['default'].createElement(Script, {
	      url: "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js",
	      onLoad: this.onScriptLoad
	    });
	  };

	  return MarkerClusterer;
	}(React.Component);

	MarkerClusterer.propTypes = {
	  map: propTypes.object,
	  markers: propTypes.array,
	  options: propTypes.object,
	  onReady: propTypes.func
	};
	MarkerClusterer.defaultProps = {
	  markers: [],
	  options: {},
	  onReady: function onReady(markerClusterer) {}
	};

	var HTMLProps = ['accept', 'acceptCharset', 'accessKey', 'action', 'allowFullScreen', 'allowTransparency', // ?
	'alt', 'async', 'autoComplete', 'autoFocus', 'autoPlay', 'capture', 'cellPadding', 'cellSpacing', 'challenge', 'charSet', 'checked', 'cite', 'classID', 'className', 'colSpan', 'cols', 'content', 'contentEditable', 'contextMenu', 'controls', 'controlsList', 'coords', 'crossOrigin', 'data', 'dateTime', 'default', 'defer', 'dir', 'disabled', 'download', 'draggable', 'encType', 'form', 'formAction', 'formEncType', 'formMethod', 'formNoValidate', 'formTarget', 'frameBorder', 'headers', 'height', 'hidden', 'high', 'href', 'hrefLang', 'htmlFor', 'httpEquiv', 'icon', 'id', 'inputMode', 'integrity', 'is', 'keyParams', 'keyType', 'kind', 'label', 'lang', 'list', 'loop', 'low', 'manifest', 'marginHeight', 'marginWidth', 'max', 'maxLength', 'media', 'mediaGroup', 'method', 'min', 'minLength', 'multiple', 'muted', 'name', 'noValidate', 'nonce', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'profile', 'radioGroup', 'readOnly', 'rel', 'required', 'reversed', 'role', 'rowSpan', 'rows', 'sandbox', 'scope', 'scoped', 'scrolling', 'seamless', 'selected', 'shape', 'size', 'sizes', 'span', 'spellCheck', 'src', 'srcDoc', 'srcLang', 'srcSet', 'start', 'step', 'style', 'summary', 'tabIndex', 'target', 'title', 'type', 'useMap', 'value', 'width', 'wmode', 'wrap'];
	var RDFProps = ['about', 'datatype', 'inlist', 'prefix', 'property', 'resource', 'typeof', 'vocab'];
	var ValidEvents = [// Clipboard Events
	'onCopy', 'onCut', 'onPaste', // Composition Events
	'onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate', // Keyboard Events
	'onKeyDown', 'onKeyPress', 'onKeyUp', // Focus Events
	'onFocus', 'onBlur', // Form Events
	'onChange', 'onInput', 'onInvalid', 'onReset', 'onSubmit', // Mouse Events
	'onClick', 'onContextMenu', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', // Pointer Events
	'onPointerDown', 'onPointerMove', 'onPointerUp', 'onPointerCancel', 'onGotPointerCapture', 'onLostPointerCapture', 'onPointerEnter', 'onPointerLeave', 'onPointerOver', 'onPointerOut', // Selection Events
	'onSelect', // Touch Events
	'onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart', // UI Events
	'onScroll', // Wheel Events
	'onWheel', // Media Events
	'onAbort', 'onCanPlay', 'onCanPlayThrough', 'onDurationChange', 'onEmptied', 'onEncrypted', 'onEnded', 'onError', 'onLoadedData', 'onLoadedMetadata', 'onLoadStart', 'onPause', 'onPlay', 'onPlaying', 'onProgress', 'onRateChange', 'onSeeked', 'onSeeking', 'onStalled', 'onSuspend', 'onTimeUpdate', 'onVolumeChange', 'onWaiting', // Image Events
	'onLoad', 'onError', // Animation Events
	'onAnimationStart', 'onAnimationEnd', 'onAnimationIteration', // Transition Events
	'onTransitionEnd', // Other Events
	'onToggle'];

	var DataRegex = /data-([a-zA-Z0-9\-]*)/;
	var AriaRegex = /aria-([a-zA-Z0-9\-]*)/;
	/**
	 * Return an object containing the valid props to apply to an HTMLElement.
	 *
	 * @param {Object} props - Props to be filtered and applied to DOM element.
	 * @param {Array} excludes - Array of props to exlude
	 * @param {Array} customAttributes - Array of custom attributes to include
	 * @return {Object}
	 */

	var cleanProps = function cleanProps(props, excludes, customAttributes) {
	  if (props === void 0) {
	    props = {};
	  }

	  if (excludes === void 0) {
	    excludes = [];
	  }

	  if (customAttributes === void 0) {
	    customAttributes = [];
	  }

	  var returnProps = Object.assign({}, props);
	  var validProps = Object.keys(returnProps).filter(function (key) {
	    if (excludes.indexOf(key) !== -1) {
	      return false;
	    }

	    if (customAttributes.indexOf(key) > -1) {
	      return true;
	    }

	    if (HTMLProps.indexOf(key) !== -1) {
	      return true;
	    }

	    if (RDFProps.indexOf(key) !== -1) {
	      return true;
	    }

	    if (DataRegex.test(key)) {
	      return true;
	    }

	    if (AriaRegex.test(key)) {
	      return true;
	    }

	    if (ValidEvents.indexOf(key) !== -1) {
	      return true;
	    }

	    return false;
	  });
	  Object.keys(returnProps).forEach(function (key) {
	    if (validProps.indexOf(key) === -1) {
	      delete returnProps[key];
	    }
	  });
	  return returnProps;
	};

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var EXCLUDE_PROPS = ['async', 'defer', 'onClick', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragStart', 'onMouseMove', 'onMouseOut', 'onMouseOver'];
	var CALLBACK_MAP = {
	  'bounds_changed': 'onBoundsChange',
	  'center_changed': 'onCenterChange',
	  'click': 'onClick',
	  'dblclick': 'onDoubleClick',
	  'drag': 'onDrag',
	  'dragend': 'onDragEnd',
	  'dragstart': 'onDragStart',
	  'heading_changed': 'onHeadingChange',
	  'idle': 'onIdle',
	  'maptypeid_change': 'onMapTypeIdChange',
	  'mousemove': 'onMouseMove',
	  'mouseout': 'onMouseOut',
	  'mouseover': 'onMouseOver',
	  'projection_changed': 'onProjectionChange',
	  'rightclick': 'onRightClick',
	  'tilesloaded': 'onTilesLoad',
	  'tilt_changed': 'onTiltChange',
	  'zoom_changed': 'onZoomChange'
	};

	if (typeof window !== 'undefined') {
	  window['reactMapsGoogleInstances'] = [];

	  window['reactMapsGoogleInit'] = function () {
	    window['reactMapsGoogleInstances'].forEach(function (instance) {
	      return instance();
	    });
	  };
	}

	var GoogleMap = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(GoogleMap, _Component);

	  function GoogleMap(props) {
	    var _this;

	    _this = _Component.call(this, props) || this;
	    var scriptLoaded = typeof window !== 'undefined' && window.google && window.google.maps && window.google.maps.Map ? true : false;
	    _this.state = {
	      map: null,
	      scriptLoaded: scriptLoaded
	    };
	    _this.onScriptLoad = _this.onScriptLoad.bind(_assertThisInitialized(_this));
	    _this.onScriptInit = _this.onScriptInit.bind(_assertThisInitialized(_this));

	    if (typeof window !== 'undefined') {
	      window['reactMapsGoogleInstances'].push(_this.onScriptInit);
	    }

	    return _this;
	  }

	  var _proto = GoogleMap.prototype;

	  _proto.componentDidMount = function componentDidMount() {
	    this.renderMap();
	  };

	  _proto.componentDidUpdate = function componentDidUpdate() {
	    this.refreshMapSettings(this.props);
	  };

	  _proto.componentWillUnmount = function componentWillUnmount() {
	    var map = this.state.map;

	    if (!map) {
	      return;
	    }

	    google.maps.event.clearInstanceListeners(map);
	  };

	  _proto.refreshMapSettings = function refreshMapSettings(props) {
	    var map = this.state.map;

	    if (!map) {
	      return;
	    }

	    var options = props.options;
	    map.setOptions(options);
	  };

	  _proto.onScriptLoad = function onScriptLoad() {
	    this.setState({
	      scriptLoaded: true
	    });
	  };

	  _proto.onScriptInit = function onScriptInit() {
	    this.renderMap();
	  };

	  _proto.onMapCallback = function onMapCallback(callback, event) {
	    var map = this.state.map;
	    this.props[callback](map, event);
	  };

	  _proto.renderMap = function renderMap() {
	    var _this2 = this;

	    if (this.state.map) {
	      return false;
	    }

	    if (!window.google || !window.google.maps || !window.google.maps.Map) {
	      return false;
	    }

	    var _this$props = this.props,
	        options = _this$props.options,
	        onReady = _this$props.onReady;
	    var mapElement = ReactDOM__default['default'].findDOMNode(this.mapRef);

	    if (!mapElement) {
	      return false;
	    }

	    var map = new google.maps.Map(mapElement, options);
	    Object.keys(CALLBACK_MAP).forEach(function (key) {
	      google.maps.event.addListener(map, key, _this2.onMapCallback.bind(_this2, CALLBACK_MAP[key]));
	    });
	    this.setState({
	      map: map
	    });
	    onReady(map);
	    return true;
	  };

	  _proto.render = function render() {
	    var _this3 = this;

	    var _this$props2 = this.props,
	        apiKey = _this$props2.apiKey,
	        children = _this$props2.children;
	    var _this$state = this.state,
	        map = _this$state.map,
	        scriptLoaded = _this$state.scriptLoaded;
	    var clonedChildren = React__default['default'].Children.toArray(children).map(function (child) {
	      return /*#__PURE__*/React__default['default'].cloneElement(child, {
	        map: map
	      });
	    });
	    return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, scriptLoaded === false && /*#__PURE__*/React__default['default'].createElement(Script, {
	      url: "https://maps.googleapis.com/maps/api/js?key=" + apiKey + "&callback=reactMapsGoogleInit",
	      onLoad: this.onScriptLoad,
	      async: this.props.async ? "async" : false,
	      defer: this.props.defer ? "defer" : false
	    }), /*#__PURE__*/React__default['default'].createElement("div", _extends({}, cleanProps(this.props, EXCLUDE_PROPS), {
	      ref: function ref(element) {
	        return _this3.mapRef = element;
	      },
	      style: {
	        height: '100%'
	      }
	    })), clonedChildren);
	  };

	  return GoogleMap;
	}(React.Component);

	GoogleMap.propTypes = {
	  apiKey: propTypes.string.isRequired,
	  async: propTypes.bool,
	  options: propTypes.object,
	  onBoundsChange: propTypes.func,
	  onCenterChange: propTypes.func,
	  onClick: propTypes.func,
	  onDoubleClick: propTypes.func,
	  onDrag: propTypes.func,
	  onDragEnd: propTypes.func,
	  onDragStart: propTypes.func,
	  onHeadingChange: propTypes.func,
	  onIdle: propTypes.func,
	  onMapTypeIdChange: propTypes.func,
	  onMouseMove: propTypes.func,
	  onMouseOut: propTypes.func,
	  onMouseOver: propTypes.func,
	  onProjectionChange: propTypes.func,
	  onRightClick: propTypes.func,
	  onTilesLoad: propTypes.func,
	  onTiltChange: propTypes.func,
	  onZoomChange: propTypes.func,
	  onReady: propTypes.func
	};
	GoogleMap.defaultProps = {
	  options: {
	    center: {
	      lat: 40.730610,
	      lng: -73.935242
	    },
	    zoom: 12
	  },
	  async: true,
	  onBoundsChange: function onBoundsChange() {},
	  onCenterChange: function onCenterChange() {},
	  onClick: function onClick() {},
	  onDoubleClick: function onDoubleClick() {},
	  onDrag: function onDrag() {},
	  onDragEnd: function onDragEnd() {},
	  onDragStart: function onDragStart() {},
	  onHeadingChange: function onHeadingChange() {},
	  onIdle: function onIdle() {},
	  onMapTypeIdChange: function onMapTypeIdChange() {},
	  onMouseMove: function onMouseMove() {},
	  onMouseOut: function onMouseOut() {},
	  onMouseOver: function onMouseOver() {},
	  onProjectionChange: function onProjectionChange() {},
	  onRightClick: function onRightClick() {},
	  onTilesLoad: function onTilesLoad() {},
	  onTiltChange: function onTiltChange() {},
	  onZoomChange: function onZoomChange() {},
	  onReady: function onReady() {}
	};

	exports.Circle = Circle;
	exports.Marker = Marker;
	exports.MarkerClusterer = MarkerClusterer;
	exports['default'] = GoogleMap;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
/* follow me on Twitter! @ryanhefner */
